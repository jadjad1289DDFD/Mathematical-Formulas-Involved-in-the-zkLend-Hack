  


# Formal Proof of the Exploit’s Existence Under Given Conditions

## Introduction

This proof demonstrates that under specific conditions, the combination of:
- A minimal initial deposit,
- An inflated global accumulator, and
- Floor division in both minting and withdrawal calculations,

creates a vulnerability that allows an attacker to extract a net surplus from the protocol.

---

## Definitions and Notation

- **T** = 10^27 (Scaling factor)
- **A** = Current (and possibly inflated) lending accumulator
- **d** = Deposit amount (in collateral)
- **z** = Number of zTokens minted upon deposit
- **w** = Withdrawal amount computed when burning zTokens
- **epsilon** = A small positive value (epsilon > 0)

The protocol uses the following formulas:

1. **Minting (Deposit)**:

   ```
   z = floor((d * T) / A)
   ```

2. **Withdrawal**:

   ```
   w = floor((z * A) / T)
   ```

---

## Step 1: Exploiting Floor Division in Minting

For an attacker to mint **1 zToken**, the deposit `d` must satisfy:

   ```
   1 <= (d * T) / A < 2
   ```

Rearranging gives:

   ```
   d >= A / T
   ```

The attacker deposits:

   ```
   d = (A / T) + epsilon
   ```

Due to floor division:

   ```
   z = floor(((A / T) + epsilon) * T / A)
     = floor(1 + (epsilon * T) / A)
     = 1
   ```

This mints exactly **1 zToken**, even though the deposited amount is slightly more than required.

---

## Step 2: Exploiting Floor Division in Withdrawal

When burning 1 zToken, the withdrawal amount is calculated as:

   ```
   w = floor((1 * A) / T)
   ```

Assume `A` can be expressed as:

   ```
   A = (k * T) + delta
   ```

Where:
- `k` is an integer
- `delta` is a remainder such that `0 < delta < T`

Then the withdrawal calculation becomes:

   ```
   w = floor(k + (delta / T))
   w = k
   ```

The result is the **integer part** of the value, meaning the remainder `(delta / T)` is discarded.

---

## Step 3: Net Surplus per Cycle

The attacker’s net surplus per deposit-withdrawal cycle is:

   ```
   gap = d - w
       = ((A / T) + epsilon) - k
       = (delta / T) + epsilon
   ```

Since `0 < delta < T` and `epsilon > 0`, the gap is **strictly positive**:

   ```
   gap > 0
   ```

This surplus is the rounding error gained in each cycle.

---

## Step 4: Cumulative Exploitation

By repeating this process `n` times, the attacker accumulates:

   ```
   Total Surplus = n * ((delta / T) + epsilon)
   ```

For sufficiently large `n`, the total surplus becomes significant, allowing the attacker to withdraw more than their initial deposit.

---

## Key Conditions for the Exploit

1. **Inflated Accumulator**:  
   `A` is much larger than `T`, making `(delta / T)` non-negligible.
   
2. **Floor Division**:  
   Both minting and withdrawal calculations use `floor()` which introduces rounding errors.

3. **Repeated Cycles**:  
   The rounding gap accumulates linearly with each cycle, allowing the attacker to extract an ever-increasing surplus.

---

## Conclusion

The combination of floor division and an inflated accumulator allows an attacker to:

1. Mint zTokens at a lower effective cost.
2. Withdraw more collateral than deposited by exploiting rounding errors.
3. Drain the protocol’s reserves by repeating the process multiple times.

This constitutes a formal proof of the exploit under the specified conditions.


